# Strategy 1: Replace the individual with the lowest fitness (original approach)
min_fitness_index = fitness_scores.index(min(fitness_scores))
population[min_fitness_index] = temp_final_child


# Strategy 2: Replace a randomly selected individual from the bottom 20% of the population
bottom_20_percent = int(len(fitness_scores) * 0.2)
bottom_indices = sorted(range(len(fitness_scores)), key=lambda i: fitness_scores[i])[:bottom_20_percent]
random_index = random.choice(bottom_indices)
population[random_index] = temp_final_child


# Strategy 3: Replace the most similar individual to the child to encourage diversity
similarity_scores = [ga.calculate_similarity(child, individual) for individual in population]
most_similar_index = similarity_scores.index(max(similarity_scores))
population[most_similar_index] = temp_final_child


# Strategy 4: Replace an individual based on a weighted probability of fitness
fitness_weights = [1 / (fitness + 1e-6) for fitness in fitness_scores]  # Avoid division by zero
cumulative_weights = [sum(fitness_weights[:i+1]) for i in range(len(fitness_weights))]
total_weight = cumulative_weights[-1]
random_value = random.uniform(0, total_weight)
selected_index = next(i for i, weight in enumerate(cumulative_weights) if weight > random_value)
population[selected_index] = temp_final_child
